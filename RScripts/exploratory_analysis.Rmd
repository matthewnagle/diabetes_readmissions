---
title: "Project"
author: "B203349"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# [Click here to link to my gpresentation](https://github.com/B203349/B203349_assessment)

# Loading the required packages required for this script

```{r echo = TRUE, warning = FALSE, message = FALSE}
library(sparklyr)
library(dplyr)
library(ggplot2)
library(cowplot)
library(knitr)
library(kableExtra)
library(tidyverse) 
library(lubridate) 
library(ggplot2)
library(dbplot)
library(janitor)
library(broom)
```

## Connecting to Spark in local mode

```{r warning = FALSE}
sc = spark_connect(master = 'local')
```

# Loading datasets 
## Data
The **Diabetes 130-US hospitals for years 1999-2008 Data Set** is an extract representing 10 years (1999â€“2008) of clinical care at 130 hospitals and integrated delivery networks throughout the United States. The dataset was compiled Strack et al[1] and is in .csv format.

## Read .csv downloaded from and create dataframe
```{r}
diabetic_data = spark_read_csv(sc, '/Users/matt/Desktop/Dropbox/Home/College/Edinburgh - MSc Data Science/Big Data Analytics/diabetes_readmissions/RawData/diabetic_data.csv') 
#diabetic_data = spark_read_csv(sc, '/home/jovyan/Matt/diabetes_readmissions/RawData/diabetic_data.csv')
```

# Exploratory analysis

##Summary of data
The dataset contains over 50 variables, broadly these describe: patient demographics, patient diagnoses, admission and discharge dispositions, length of stay, blood glucose levels, medication types and changes, and readmission data. Furthermore, procedures, medications, and outpatient / inpatient / ED visits are all also quantified. The full list of variables is outlined below: 

```{r}
glimpse(diabetic_data)
```

# Data cleaning, exploration, and feature engineering

## Conversion of '?' to NA
From review of the dataframe is a apparent that '?' is used instead of NA. To faciliate data cleaning and wrangling '?' is switched to NA.
```{r}
#replace '?' with NA
diabetic_data <- diabetic_data %>%
  mutate(across(where(is.character), ~na_if(., "?")))
```

## Duplicate patients
The dataset contains 16,773 patients with multiple admissions (accounting for 47,021 observed admissions). As outlined by the code below:
```{r}
#total number of patient encounters 
total_number_of_patient_encounters <-pull(diabetic_data, patient_nbr)%>%
  length()

#number of patients with repeat encounters
number_of_patient_with_repeat_encounters <- diabetic_data %>%
  group_by(patient_nbr) %>%
  filter(n()>1) %>%
  tally() %>%
  sdf_nrow()

#number of patient encounters that can be classified as 'repeat'
number_of_patient_classed_as_repeat <- diabetic_data %>%
  group_by(patient_nbr) %>%
  filter(n()>1) %>%
  sdf_nrow()


print(paste("Total number of patient encounters:", total_number_of_patient_encounters))
print(paste("Number of patients with repeat encounters:", number_of_patient_with_repeat_encounters))
print(paste("Number of patient encounters that can be classified as 'repeat':", number_of_patient_classed_as_repeat))

```

### Removing duplicate patients
It cannot be assumed that the reason for these repeat admissions are independent. Statistical independence between observations is an assumption in some predictive models e.g. logistic regression. Therefore the dataset was cleaned to include only the **initial encounter** of repeat patients using the following code: 

```{r}
#group by patient number then select only the earliest patient encounter
diabetic_data <- diabetic_data %>% 
  group_by(patient_nbr) %>%
  slice_min(encounter_id) %>% #slice_min selects the rows with lowest values
  ungroup()
```

Once this is done `patient_nbr` and `ecnounter_id` are redundant so these columns are removed

```{r}
diabetic_data <- select(diabetic_data, -c(patient_nbr, encounter_id))
```

## Missing variables
```{r}
#count the number of  NAs per column
NA_count <- diabetic_data %>%
  summarise_all(~sum(as.integer(is.na(.)))) %>%
  collect()

#transpose dataframe (convert from wide to long)
NA_count <- t(NA_count) 

#rename column 1 to missing_values
colnames(NA_count)[1] ="missing_values"

kable(NA_count)
```

From the table above it is clear that `weight`, `payer_code` and `medical_speciality` have a significant number of missing variables. The exact percentage of missing variables is further explored below:

```{r}
diabetic_data %>% 
  count(medical_specialty) %>%
  mutate(percent_missing = ((n / sum(n))*100)) %>% 
  filter(is.na(medical_specialty))

diabetic_data %>% 
  count(payer_code) %>%
  mutate(percent_missing = ((n / sum(n))*100)) %>% 
  filter(is.na(payer_code))

diabetic_data %>% 
  count(weight) %>%
  mutate(percent_missing = ((n / sum(n))*100)) %>% 
  filter(is.na(weight))
```
Given the amount of missing values from `weight` this column is removed from inclusion in further analysis
```{r}
diabetic_data <- select(diabetic_data, -c(weight))
```

## Exploration of numericcal variables
### Summary stats numerical variables
```{r}
summary_stats_num_var <- sdf_describe(diabetic_data, cols = 
               c('time_in_hospital',
                 'num_medications',
                 'number_inpatient',
                 'num_lab_procedures',
                 'number_outpatient',
                 'number_diagnoses',
                 'num_procedures',
                 'number_emergency'))

kable(summary_stats_num_var) %>%
  kable_styling(latex_options = "scale_down")
```

## Visualisation of numerical variables
```{r}
#create summary groups of numerical variable to collect and use in ggplot
time_in_hospital_group = diabetic_data %>% 
  count(time_in_hospital) %>%
  arrange(time_in_hospital) %>%
  collect()

num_medications_group = diabetic_data %>% 
  count(num_medications) %>%
  arrange(num_medications) %>%
  collect()

number_inpatient_group = diabetic_data %>% 
  count(number_inpatient) %>%
  arrange(number_inpatient) %>%
  collect()

num_lab_procedures_group = diabetic_data %>% 
  count(num_lab_procedures) %>%
  arrange(num_lab_procedures) %>%
  collect()

number_outpatient_group = diabetic_data %>% 
  count(number_outpatient) %>%
  arrange(number_outpatient) %>%
  collect()

number_diagnoses_group = diabetic_data %>% 
  count(number_diagnoses) %>%
  arrange(number_diagnoses) %>%
  collect()

num_procedures_group = diabetic_data %>% 
  count(num_procedures) %>%
  arrange(num_procedures) %>%
  collect()

number_emergency_group = diabetic_data %>% 
  count(number_emergency) %>%
  arrange(number_emergency) %>%
  collect()

#create plots
time_in_hospital_plot <- 
  ggplot(aes(as.numeric(time_in_hospital), n), data = time_in_hospital_group) +
  geom_col(fill = 'SteelBlue') +
  scale_x_continuous(breaks=seq(0, 20, 2))  +
  xlab('Time in hospital (days)') +
  ylab('Count')

num_medications_plot <- 
  ggplot(aes(as.numeric(num_medications), n), data = num_medications_group) +
  geom_col(fill = 'SteelBlue') +
  scale_x_continuous(breaks=seq(0, 80, 10))  +
  xlab('Number of medications') +
  ylab('Count')

number_inpatient_plot <- 
  ggplot(aes(as.numeric(number_inpatient), n), data = number_inpatient_group) +
  geom_col(fill = 'SteelBlue') +
  #scale_x_continuous(breaks=seq(0, 15, 5))  +
  xlab('Number of inpatient visits \n(within preceding year)') +
  ylab('Count')

number_outpatient_plot <- 
  ggplot(aes(as.numeric(number_outpatient), n), data = number_outpatient_group) +
  geom_col(fill = 'SteelBlue') +
  scale_x_continuous(breaks=seq(0, 40, 5))  +
  xlab('Number of outpatient visits \n(within preceding year)') +
  ylab('Count')

number_emergency_plot <- 
  ggplot(aes(as.numeric(number_emergency), n), data = number_emergency_group) +
  geom_col(fill = 'SteelBlue') +
  xlab('Number of emergency visits \n(within preceding year)') +
  ylab('Count')

num_lab_procedures_plot <- 
  ggplot(aes(as.numeric(num_lab_procedures), n), data = num_lab_procedures_group) +
  geom_col(fill = 'SteelBlue') +
  xlab('Number of lab tests performed') +
  ylab('Count')

num_procedures_plot <- 
  ggplot(aes(as.numeric(num_procedures), n), data = num_procedures_group) +
  geom_col(fill = 'SteelBlue') +
  xlab('Number of procedures performed') +
  ylab('Count')

number_diagnoses_plot <- 
  ggplot(aes(as.numeric(number_diagnoses), n), data = number_diagnoses_group) +
  geom_col(fill = 'SteelBlue') +
  xlab('Number of diagnoses') +
  ylab('Count')

#combine plots into one grid
plot_grid(time_in_hospital_plot,
          num_medications_plot,
          number_inpatient_plot,
          number_outpatient_plot,
          number_emergency_plot,
          num_lab_procedures_plot,
          num_procedures_plot,
          number_diagnoses_plot)
```
# Exploration and feature engineering of categorical variables
## Age, Race, and gender
##Visualisation of Age, Race, and gender
```{r}
# Data manipulations are done first using spark and collected
age_group = diabetic_data %>% 
  count(age) %>%
  arrange(age) %>%
  collect()

race_group = diabetic_data %>% 
  count(race) %>%
  arrange(race) %>%
  collect()

gender_group = diabetic_data %>% 
  count(gender) %>%
  arrange(gender) %>%
  collect()


#plots created with ggplot
age_plot <- 
  ggplot(aes(as.factor(age), n), data = age_group) +
  geom_col(fill = 'SteelBlue') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  xlab('Age group') +
  ylab('Count')

race_plot <-
  ggplot(aes(as.factor(race), n), data = race_group) +
  geom_col(fill = 'SteelBlue') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  xlab('Race') +
  ylab('Count')

gender_plot <-
  ggplot(aes(as.factor(gender), n), data = gender_group) +
  geom_col(fill = 'SteelBlue') +
  xlab('Gender') +
  ylab('Count')


plot_grid(age_plot, race_plot, gender_plot)
```

### Feature engineering of 'Age'
Age is converted to an ordinal scale, using the central age from each category. i.e. patients classed as age [10-20) are given the value.
```{r}
diabetic_data <- diabetic_data %>%
  mutate(
    age_contin = case_when(
      age == '[0-10)'    ~ 5,
      age == '[10-20)'   ~ 15,
      age == '[20-30)'   ~ 25,
      age == '[30-40)'   ~ 35,
      age == '[40-50)'   ~ 45,
      age == '[50-60)'   ~ 55,
      age == '[60-70)'   ~ 65,
      age == '[70-80)'   ~ 75,
      age == '[80-90)'   ~ 85,
      age == '[90-100)'  ~ 95
    ))
```

### Feature engineering of 'Race'
Race is one hot encoded
```{r}
diabetic_data <- diabetic_data %>%
  mutate(
    asian = ifelse(race == 'Asian', 1,0),
    african_american = ifelse(race == 'AfricanAmerican', 1,0),
    caucasian = ifelse(race == 'Caucasian', 1,0),
    hispanic = ifelse(race == 'Hispanic', 1,0),
    unknown_race = ifelse(is.na(race), 1,0),
  )
```

### Feature engineering of 'Gender'
Gender is on hot encoded
```{r}
diabetic_data <- diabetic_data %>%
  mutate(
    female = ifelse(race == 'Female', 1,0),
    gender_unknown_invalid = ifelse(race == 'Unknown/Invalid', 1,0),
    male = ifelse(race == 'Male', 1,0)
  )
```

## Readmissions
View the breakdown of readmissions

```{r diabetic_data}
diabetic_data %>% 
  count(readmitted) %>%
  kable()
```

Create a new variable that classifies those readmitted within 30 days and those not, as this is the specific question posed by the challenge.

```{r}
## create a new column with readmission <30
diabetic_data = mutate(diabetic_data, early_readmission = ifelse(readmitted == '<30', 1, 0))

diabetic_data %>%
  group_by(early_readmission) %>%
  tally() %>%
  kable()
```

## Diagnoses
With regard to the diagnosis variables (`diag_1`, `diag_2`, and `diag_3`) initial exploration determines the exact number of different diagnosis categories.
```{r}
#count of the number of unique primary Dx (698)
n_primary_dx <- diabetic_data %>%
  summarise(count = n_distinct(diag_1))

#count of the number of unique secondary Dx (749)
n_secondary_dx <- diabetic_data %>%
  summarise(count = n_distinct(diag_2))

#count of the number of unique tertiary Dx (759)
n_tertiary_dx <- diabetic_data %>%
  summarise(count = n_distinct(diag_3))


print(paste("Total number of different primary diagnosis categories:", n_primary_dx))
print(paste("Total number of different secondary diagnosis categories:", n_secondary_dx))
print(paste("Total number of different tertiary diagnosis categories:", n_tertiary_dx))
```
As illustrated above there are 698 unique primary diagnoses, 749 unique secondary diagnoses, and 759 tertiary diagnoses. Maintaining categorical variables with such high levels will be computationally expensive, diagnoses will be consolidated into more manageable levels.
This is performed below using the ICD-9 code. Diagnoses have been consolidated according to the ICD-9 chapters, with each chapter essentially representing a different bodily system. A seperate category for diabetes has also been created. It should be noted that this still results in 19 categories. 

```{r}
#consolidate according to ICD9 code
diabetic_data <- diabetic_data %>%
  mutate(
    diag_1_cat = case_when(
      rlike(diag_1, "250") ~ 'diabetes', #case_when works in order therefore 'diabetes' will be classed before 'endo_metabolic_immunity'
      diag_1 >= 000 & diag_1 < 140 ~ 'infection',
      diag_1 >= 140 & diag_1 < 240 ~ 'neoplasms',
      diag_1 >= 240 & diag_1 < 280 ~ 'endo_metabolic_immunity',
      diag_1 >= 280 & diag_1 < 290 ~ 'haematology',
      diag_1 >= 290 & diag_1 < 320 ~ 'mental',
      diag_1 >= 320 & diag_1 < 390 ~ 'neurology',
      diag_1 >= 390 & diag_1 < 460 ~ 'circulatory',
      diag_1 >= 460 & diag_1 < 520 ~ 'respiratory',
      diag_1 >= 520 & diag_1 < 580 ~ 'digestive',
      diag_1 >= 580 & diag_1 < 630 ~ 'genitourinary',
      diag_1 >= 630 & diag_1 < 680 ~ 'preg_birth_puerperium',
      diag_1 >= 680 & diag_1 < 710 ~ 'dermatology',
      diag_1 >= 710 & diag_1 < 740 ~ 'musculoskeletal',
      diag_1 >= 740 & diag_1 < 760 ~ 'congenital',
      diag_1 >= 760 & diag_1 < 780 ~ 'perinatal',
      diag_1 >= 780 & diag_1 < 800 ~ 'ill_defined',
      diag_1 >= 800 & diag_1 < 1000 ~ 'injury_poisoning',
      rlike(diag_1, "V") | rlike(diag_1, "E") ~ 'supplementary',
      is.na(diag_1) ~ 'unknown_diag_1', #NA variables do not get special treatment
      TRUE ~ diag_1),
    diag_2_cat = case_when(
      rlike(diag_2, "250") ~ 'diabetes', #case_when work in order
      diag_2 >= 000 & diag_2 < 140 ~ 'infection',
      diag_2 >= 140 & diag_2 < 240 ~ 'neoplasms',
      diag_2 >= 240 & diag_2 < 280 ~ 'endo_metabolic_immunity',
      diag_2 >= 280 & diag_2 < 290 ~ 'haematology',
      diag_2 >= 290 & diag_2 < 320 ~ 'mental',
      diag_2 >= 320 & diag_2 < 390 ~ 'neurology',
      diag_2 >= 390 & diag_2 < 460 ~ 'circulatory',
      diag_2 >= 460 & diag_2 < 520 ~ 'respiratory',
      diag_2 >= 520 & diag_2 < 580 ~ 'digestive',
      diag_2 >= 580 & diag_2 < 630 ~ 'genitourinary',
      diag_2 >= 630 & diag_2 < 680 ~ 'preg_birth_puerperium',
      diag_2 >= 680 & diag_2 < 710 ~ 'dermatology',
      diag_2 >= 710 & diag_2 < 740 ~ 'musculoskeletal',
      diag_2 >= 740 & diag_2 < 760 ~ 'congenital',
      diag_2 >= 760 & diag_2 < 780 ~ 'perinatal',
      diag_2 >= 780 & diag_2 < 800 ~ 'ill_defined',
      diag_2 >= 800 & diag_2 < 1000 ~ 'injury_poisoning',
      rlike(diag_2, "V") | rlike(diag_2, "E") ~ 'supplementary',
      is.na(diag_2) ~ 'unknown_diag_2', #NA variable do not get special treatment
      TRUE ~ diag_2),
    diag_3_cat = case_when(
      rlike(diag_3, "250") ~ 'diabetes', #case_when work in order
      diag_3 >= 000 & diag_3 < 140 ~ 'infection',
      diag_3 >= 140 & diag_3 < 240 ~ 'neoplasms',
      diag_3 >= 240 & diag_3 < 280 ~ 'endo_metabolic_immunity',
      diag_3 >= 280 & diag_3 < 290 ~ 'haematology',
      diag_3 >= 290 & diag_3 < 320 ~ 'mental',
      diag_3 >= 320 & diag_3 < 390 ~ 'neurology',
      diag_3 >= 390 & diag_3 < 460 ~ 'circulatory',
      diag_3 >= 460 & diag_3 < 520 ~ 'respiratory',
      diag_3 >= 520 & diag_3 < 580 ~ 'digestive',
      diag_3 >= 580 & diag_3 < 630 ~ 'genitourinary',
      diag_3 >= 630 & diag_3 < 680 ~ 'preg_birth_puerperium',
      diag_3 >= 680 & diag_3 < 710 ~ 'dermatology',
      diag_3 >= 710 & diag_3 < 740 ~ 'musculoskeletal',
      diag_3 >= 740 & diag_3 < 760 ~ 'congenital',
      diag_3 >= 760 & diag_3 < 780 ~ 'perinatal',
      diag_3 >= 780 & diag_3 < 800 ~ 'ill_defined',
      diag_3 >= 800 & diag_3 < 1000 ~ 'injury_poisoning',
      rlike(diag_3, "V") | rlike(diag_3, "E") ~ 'supplementary',
      is.na(diag_3) ~ 'unknown_diag_3', #NA variable do not get special treatment
      TRUE ~ diag_3)
  )
```

## proportion of patient gender
```{r diabetic_data}
diabetic_data %>% 
  count(gender) # %>%
  #kable()
```
## Summary statistics
Lab procedures
```{r}
summarise(diabetic_data, mean_num_lab_procedures = mean(num_lab_procedures))
summarise(diabetic_data, min_num_lab_procedures = min(num_lab_procedures))
summarise(diabetic_data, max_num_lab_procedures = max(num_lab_procedures))
median(pull(diabetic_data, num_lab_procedures))
IQR(pull(diabetic_data, num_lab_procedures))
```
Lab procedures by age
```{r}
diabetic_data %>%
  group_by(age) %>%
  summarise(mean_num_lab_procedures = mean(num_lab_procedures)) %>%
  arrange(age)

```

## Diagnoses
list the primary diagnoses
```{r diabetic_data}
diabetic_data %>% 
  count(diag_1) %>%
  #head(15) %>% #reduces to top 15 diagnoses
  arrange(desc(n))%>%
  kable()
```
List the secondary diagnoses
```{r diabetic_data}
diabetic_data %>% 
  count(diag_2) %>%
  #head(15) %>% #reduces to top 15 diagnoses
  arrange(desc(n))%>%
  kable()
```

list the additional secondary diagnoses
```{r diabetic_data}
diabetic_data %>% 
  count(diag_3) %>%
  #head(15) %>% #reduces to top 15 diagnoses
  arrange(desc(n))%>%
  kable()
```

# Plots

```{r}
# Data manipulations are done first using spark
car_group = cars %>%
  group_by(cyl) %>%
  summarise(mpg = sum(mpg, na.rm = TRUE)) %>%
  # collect brings the Spark dataframe back to a regular R dataframe
  collect()

# Now use ggplot on the R dataframe car_group
ggplot(aes(as.factor(cyl), mpg), data = car_group) +
  geom_col(fill = 'SteelBlue') +
  xlab('Cylinders') +
  coord_flip()
```
Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
